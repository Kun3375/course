### 关于GC选择

#### SerialGC
- 将内存分为年轻代和老年代，标记复制算法用于young，编辑清理压缩的算法用于old。
- **缺点** 相对其他方案而言地，几乎没有优点。仅使用一个线程执行整个回收过程，且不能和业务程序线程并行， 也就是垃圾回收期间只能使用一个核心，对于现代计算机而言这毫无意义，几乎没有使用价值。
- 12C2G 测试 GCLogAnalysis 每次暂停在 20 毫秒级别

#### Parallel
- 对年轻代老年代的回收算法和 SerialGC 保持了一致，默认 1:2 地分配两个区，增加了回收过程中的多线程并行的能力（默认线程数为核心数，一般不用调整）。这是 JDK8 默认方案。
- **缺点** 但是整个流程依然无法和业务线程并行（全流程 STW），一旦触发 GC，会意味着业务有一个较大的暂停，对于延迟敏感的业务需要慎重考虑该方案。
- **优点** 因为暂停了业务，而且充分利用了多核心优势。从单次的效率和速度上来说无疑是最优的。
- **优点** 同时 GC 间隔期间没占用系统资源，相对其他方案，可以将吞吐量做到最大。 
- 12C2G 测试 GCLogAnalysis 每次暂停在 20 毫秒级别，相对 SerialGC 更快单没有达到提高一个数量级。

#### CMS
- 并发标记清除算法，这个回收方案是针对 Old 区的，Young 区的 GC 依旧选择标记复制来做；
- **优点** 相对于 ParallelGC 不需要完全暂停业务，仅两次标记时扫描 GC Roots 不可避免，但是跟对象少扫描十分快速，这样就使得 CMS 成了一个延迟很低回收器
- **缺点** 相应的，和业务线程并行处理逻辑比较多，会对业务整个的吞吐量有影响
- **缺点** 标记清除，会造成内存碎片，如果有以为不够连续内存而无法分配对象的情况会触发 FullGC（SerialOld），这样整个过程业务就被暂停，和选择 CMS 的初衷相悖，尽管是 CMS 的特点，也看做一个缺点吧
- **缺点** 并发清除过程中可能会错过新产生的垃圾（浮动垃圾），只能在下次回收中被清理
- **补充** CMS 有扫描线程监察 Old 的消耗占比，而不是申请空间失败时候触发，扫描间隔和占比可以单独配置
- 整个流程分为六个阶段
1. 初始标记 可以在 GC 日志中看到 `CMS Initial Mark`，这个阶段需要扫描 GC roots，STW
2. 并发标记 `CMS-concurrent-mark` 和业务线程并发执行，标记引用涉及到的对象；同时如果有已标记对象有引用变更，所在 Card 会记为 Dirty
3. 并发预清理 `CMS-concurrent-preclean` `CMS-concurrent-abortable-preclean` 重新扫描 DirtyCard 的存活对象及其引用，并在有限条件下（循环次数、消耗时间等）继续预清理的内容、一般配合 YoungGC 的过程，使得 CMS 两次 STW 的性价比尽可能的高一点
4. 最终标记(重新标记) `CMS Final Remark` 预清理的过程最终会停下，因为是业务并行的，所以仍有一部分引用需要处理
5. 并发清除 `CMS-concurrent-sweep` 处理垃圾，这一步是可能产生浮动垃圾的
6. 并发重置 `CMS-concurrent-reset` 收尾工作

#### G1
- **优点** G1 也是一个低延迟的垃圾回收器，同时设计目标是把每次回收造成的暂停时间时间控制在期望时间内
- **优点** 将内存按一定大小分割，每个区块的性质（Young/Old/Huge）灵活可变；每次回收预估垃圾多的分块来做到时间控制，不需要整堆扫描，可以适应更大的内存 4GB+ 依然优秀
- **缺点** 和 CMS 一样失败时一样会退化 FullGC，依然是期望之外的大暂停；由于一般 G1 可能使用更大的堆内存，一个 FullGC 可能比 CMS 退化时更严重
- G1 本身是一个混合型的回收器，可以同时处理 Young & Old；年轻代回收原理同标记复制
- Old 区回收首次为占用 45% 触发，之后会根据暂停时间自适应调整，同时回收 Young & Old；流程类同 CMS